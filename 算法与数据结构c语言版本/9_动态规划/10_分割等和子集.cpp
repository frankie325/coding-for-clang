#include <iostream>
#include <vector>
using namespace std;

/*
题目难易：中等

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

示例 1:

输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
示例 2:

输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.


可以将[1, 5, 11, 5]转换为背包问题，
1+5+11+5 = 22   22/2 = 11;

背包的容量为11
1,5,11,5 可以看成是4件物品，每件物品的重量和价值都是数组中的元素

也就是看能不能找到填满背包容量11的物品。
剩下的物品价值之和必然也是11
*/

int main()
{
    vector<int> nums = {1, 5, 11, 5}; // 物品的重量和价值
    int sums = 0;
    for (auto &&i : nums)
    {
        sums += i;
    }

    int n = nums.size();      // 物品数量
    int bagweight = sums / 2; // 背包容量

    vector<int> dp(bagweight + 1, 0);
    // 1.确定dp数组的含义：dp[j] 容量为j的背包，所背的物品价值可以最大为dp[j]
    // 一维dp数组，其实就是将上一层 dp[i-1] 这一层 拷贝的 dp[i]来。

    // 2.递推公式： dp[j]是上一个物品的最大价值
    // dp[j] = max(dp[j], dp[j-weight[i]]+ value[i])

    // 3.初始化
    // 容量为j的背包，所背的物品价值可以最大为dp[j]，
    // 那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

    // 4.循环
    // 外层遍历物品
    for (int i = 0; i < n; i++)
    {
        // 内层循遍历背包重量
        // !注意：内层循环一定要倒序遍历，因为dp[j]依赖于上一层物品的dp[j]值
        // !如果正序遍历，将会把依赖的上一层物品的dp[j]值重置掉
        // 遍历到j >=物品自身重量即可，背包容量小于物品重量则不能放物品了，dp[j]价值不用改变
        for (int j = bagweight; j >= nums[i]; j--)
        {
            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }

    // 如果背包容量11 == dp[11]，则说明有元素之和为11
    bool result = dp[bagweight] == bagweight;

    cout << "结果为：" << result << endl;
}